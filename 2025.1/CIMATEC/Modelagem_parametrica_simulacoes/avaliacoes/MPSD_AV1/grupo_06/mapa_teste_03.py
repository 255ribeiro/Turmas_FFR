# -*- coding: utf-8 -*-
"""mapa_teste_03.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Y-PJgCh69RYf7CbvIkbGCaIVIsd1Zjvn
"""

# Instala o contextily para adicionar mapas de fundo (como OpenStreetMap)
!pip install contextily

# Instala o mapclassify para classificar dados em faixas (útil em mapas temáticos)
!pip install mapclassify

# Importando bibliotecas necessárias
import geopandas as gpd
import matplotlib.pyplot as plt
import contextily as ctx
import numpy as np
import pandas as pd
from shapely.geometry import Point

# Leitura da malha preliminar da Bahia e filtragem apenas para Salvador
gdf = gpd.read_file('BA_Malha_Preliminar_2022.json')
salvador_gdf = gdf[gdf['NM_MUN'] == 'Salvador'].copy()

# Mapa geral da Bahia com destaque leve nos setores
fig, ax = plt.subplots(figsize=(12, 8))
gdf.plot(ax=ax, color='lightblue', edgecolor='black', linewidth=0.5, alpha=0.5)
plt.title("Mapa Preliminar de Setores - Abaíra/BA (2022)", fontsize=14)
ax.set_axis_off()
plt.show()

# Projeção web mercator para plotagem com basemap
salvador_gdf_web = salvador_gdf.to_crs(epsg=3857)
fig, ax = plt.subplots(figsize=(15, 10))
salvador_gdf_web.plot(ax=ax, color='lightblue', edgecolor='navy', linewidth=0.5, alpha=0.6)
ctx.add_basemap(ax, source=ctx.providers.OpenStreetMap.Mapnik, zoom=13, crs=salvador_gdf_web.crs.to_string())
ax.set_xlim(salvador_gdf_web.total_bounds[0], salvador_gdf_web.total_bounds[2])
ax.set_ylim(salvador_gdf_web.total_bounds[1], salvador_gdf_web.total_bounds[3])
plt.title("Setores Censitários - Salvador/BA (Alinhado com OpenStreetMap)", fontsize=16)
ax.set_axis_off()
plt.savefig('mapa_salvador_alinhado.png', dpi=300, bbox_inches='tight')
plt.show()

# Conversão para SIRGAS 2000 / UTM zone 24S para cálculos de área
salvador_gdf = salvador_gdf.to_crs(epsg=31984)
salvador_gdf['v0001'] = pd.to_numeric(salvador_gdf['v0001'], errors='coerce')

# Cálculo da área em km² usando projeção métrica
salvador_gdf['area_km2'] = salvador_gdf.geometry.to_crs(epsg=3395).area / 1e6
salvador_gdf['densidade'] = salvador_gdf['v0001'] / salvador_gdf['area_km2']

# Criação de um ponto central (exemplo de coordenada)
coords = (-38.382914, -12.927827)
ponto = gpd.GeoDataFrame(geometry=[Point(coords)], crs='EPSG:4326')
ponto = ponto.to_crs(epsg=31984)

# Criação do buffer de 1 km em torno do ponto
buffer_1km = ponto.buffer(1000)

# Substituindo unary_union por union_all() (evita warning)
buffer_1km_union = buffer_1km.union_all()

# Filtra os setores que intersectam com o buffer
setores_1km = salvador_gdf[salvador_gdf.intersects(buffer_1km_union)]

# Mapa dos setores dentro do buffer com coloração por densidade
fig, ax = plt.subplots(figsize=(10, 10))
setores_1km.plot(column='densidade', cmap='viridis', legend=True, ax=ax, edgecolor='black', alpha=0.7)

# Plotando o limite do buffer (transformado em GeoSeries para evitar erro)
gpd.GeoSeries(buffer_1km_union).boundary.plot(ax=ax, color='red', linestyle='--', linewidth=2)

# Plotando o ponto central
ponto.plot(ax=ax, color='black', markersize=50)

# Adicionando mapa de fundo
ctx.add_basemap(ax, crs=salvador_gdf.crs.to_string(), source=ctx.providers.CartoDB.Positron)
ax.set_title('Setores Censitários em um Raio de 1km do Ponto Central', fontsize=14)
ax.set_axis_off()
plt.tight_layout()
plt.show()

# Segunda visualização com título e anotação
fig, ax = plt.subplots(figsize=(12, 10))
setores_1km.plot(column='densidade', cmap='viridis', legend=True, ax=ax, edgecolor='black')
leg = ax.get_legend()
if leg is not None:
    leg.set_title('Densidade Populacional\n(hab/km²)')

# Novamente usando GeoSeries para evitar erro ao plotar
gpd.GeoSeries(buffer_1km_union).boundary.plot(ax=ax, color='red', linestyle='--', linewidth=2)
ponto.to_crs(epsg=31984).plot(ax=ax, color='blue', markersize=80, zorder=5)

# Texto com nome do ponto
x, y = ponto.geometry.iloc[0].xy
ax.text(x[0] + 20, y[0] + 20, 'Terreno escolhido', fontsize=12, color='blue')
ax.set_title('Densidade Demográfica em um Raio de 1km - Salvador', fontsize=15)
ctx.add_basemap(ax, source=ctx.providers.CartoDB.Positron, crs=setores_1km.crs.to_string())
ax.axis('off')
plt.ticklabel_format(style='plain', useOffset=False)
plt.show()